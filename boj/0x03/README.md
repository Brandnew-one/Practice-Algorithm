# 0x03 배열
[바킹독의 알고리즘 강좌](https://blog.encrypted.gg/927)를 듣고 정리한 내용입니다.

## C++ 기준

### 배열의 성질

- O(1)의 시간복잡도로 k번째 원소를 확인/변경
- Cache hit rate가 높음 (검색 필요)
- 원소를 끝에 추가 O(1)
- 마지막 원소 제거 O(1)
- 임의의 위치에 원소를 추가/제거 O(N)

사실을 배열에 대해서 자세하게 설명할만한 내용이 없어서 배열을 선언하고 값을 할당하는 tip 정도를 정리

### 배열

```cpp
// 특정값으로 할당하면서 초기화하는 경우
int a[21];
int b[21][21];

fill(a, a + 21, 0);
fill(int i = 0; i < 21; i++) {
	fill(b[i], b[i] + 21, 0);
}
```

값을 할당하면서 초기화 시키는 방법은 다양하게 존재하지만 algorithm 헤더에 존재하는 fill 메서드를 사용하는 것이 가장 간단하고 효율적

### 벡터

- 배열에 비해 크기를 자유자재로 늘이거나 줄일 수 있음 (동적으로)
- 일반적으로 프로그래머스에서 제공하는 반환 타입이 vector이기 때문에 친숙해질 필요가 있음

```cpp
vector<int> v1(3, 5); // {5, 5, 5}
v1.push_back(7); // {5, 5, 5, 7}

vector<int> v2(2); // {0, 0}
v2.insert(v2.begin() + 1, 3); // {0, 3, 0}

vector<int> v3;
v3 = v2; // deep copy {0, 3, 0}
v3.pop_back(); //{0, 3} -> v2에 변화x
```

```cpp
vector<int> v1 = {1, 2, 3};

// range-based-loop c++11 부터 지원
for(int e : v1) {
	cout << e << ' ';
}
// 1 2 3

// 레퍼런스를 이용해서 실제 v1의 원소의 값을 변경할 수도 있음
for(int& e : v1) {
	cout << e << ' ';
}
```

vector를 순회하는 방법은 c언어에서 사용하던 방식과 동일한 방식을 사용하거나 위의 범위 loop를 사용해서도 가능하다

```cpp
for(int i = 0; i <= v1.size() - 1; i++) {
	cout << v1[i] << ' ';
}
```

하지만 vector의 사이즈는 unsigned int 값을 반환하기 때문에 위와 같이 코드를 작성할 경우 vector가 비어 있는 경우 예상치 못한 실행결과를 얻을 수 있기 때문에 주의해야 한다.
